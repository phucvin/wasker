#include <stdio.h>
#include <stdlib.h>

extern void wasker_main();

long linear_memory_base;
int linear_memory_block_num = 0;
const int LINEAR_MEMORY_BLOCK_SIZE = 64 * 1024;
const int LINEAR_MEMORY_BLOCK_NUM_MAX = 32;


//////////////////////////////////////////////
/// Wrapper of following WASI functions
/// - fd_write
/// - environ_get
/// - environ_sizes_get
/// - proc_exit
//////////////////////////////////////////////

typedef struct {
  int iov_base;
  int iov_len;
} IoVec;

typedef struct {
  char tag;
  int len;
} Prestat;

typedef enum {
    SUCCESS,
    // Add other error types here
} WasiError;

WasiError path_open(int fd, int dirflags, int path_addr, int path_length, int oflags, long long rights_base, long long rights_inferiting, int fdflags, int opened_fd_addr) {
    printf("[host] path_open fd=%d opened_fd_addr=%d\n", fd, opened_fd_addr);
    int* p = (int*)(linear_memory_base + opened_fd_addr);
    *p = 4;
    return SUCCESS;
}

WasiError fd_filestat_get(int fd) {
    printf("[host] fd_filestat_get fd=%d\n", fd);
}

WasiError fd_prestat_get(int fd, int addr) {
    printf("[host] fd_prestat_get fd=%d addr=%d\n", fd, addr);
    if (fd != 3) return 8;  // BADF
    Prestat* p = (Prestat*)(linear_memory_base + addr);
    p->tag = 0;
    p->len = 1;
    return SUCCESS;
}

WasiError fd_prestat_dir_name(int fd, int addr, int len) {
    printf("[host] fd_prestat_dir_name fd=%d addr=%d len=%d\n", fd, addr, len);
    char* p = (char*)(linear_memory_base + addr);
    *p = 'a';
    return SUCCESS;
}

WasiError fd_close(int fd) {
    printf("[host] fd_close fd=%d\n", fd);
    return SUCCESS;
}

WasiError fd_read(int fd, int buf_iovec_addr, int vec_len, int size_addr) {
    printf("[host] fd_read fd=%d vec_len=%d size_addr=%d\n", fd, vec_len, size_addr);
    if (vec_len != 1) return 29;  // IO
    IoVec* iovec = (IoVec*)(linear_memory_base + buf_iovec_addr);
    char* buf_ptr = (char *)(linear_memory_base + iovec[0].iov_base);
    size_t buf_len = iovec[0].iov_len;
    printf("[host] fd_read buf_len=%d\n", buf_len);
    for (int i = 0; i < buf_len - 1; ++i) buf_ptr[i] = 'A' + (i % 16);
    int* size_ptr = (int *)(linear_memory_base + size_addr);
    *size_ptr = buf_len - 1;
    return SUCCESS;
}

WasiError fd_write(int fd, int buf_iovec_addr, int vec_len, int size_addr) {
    printf("[host] fd_write fd=%d vec_len=%d size_addr=%d\n", fd, vec_len, size_addr);
    IoVec* iovec = (IoVec*)(linear_memory_base + buf_iovec_addr);

    int len = 0;
    for (int i = 0; i < vec_len; i++){
        char* buf_ptr = (char *)(linear_memory_base + iovec[i].iov_base);
        size_t buf_len = iovec[i].iov_len;
        for (int j = 0; j < buf_len; j++){
            printf("%c", buf_ptr[j]);
        }
        len += buf_len;
    }
    int* size_ptr = (int *)(linear_memory_base + size_addr);
    *size_ptr = len;
    return SUCCESS;
}

WasiError environ_get(int env_addrs, int env_buf_addr){
  printf("[host] environ_get\n");
  // TODO: implement
  return SUCCESS;
}

WasiError environ_sizes_get(int env_count_addr, int env_buf_size_addr){
  printf("[host] environ_sizes_get\n");
  // TODO: implement
  return SUCCESS;
}

void proc_exit(int code){
  printf("[host] proc_exit\n");
  exit(code);
}

//////////////////////////////////////////////
/// Provide linear memory with Wasm
//////////////////////////////////////////////

long memory_base(){
  printf("[host] memory_base\n");
  // malloc 32 Block for linear memory
  char* memory = (char*)malloc(LINEAR_MEMORY_BLOCK_SIZE * LINEAR_MEMORY_BLOCK_NUM_MAX);
  linear_memory_base = (long)memory;
  return linear_memory_base;
}

long memory_grow(long num){
  printf("[host] memory_grow\n");
  int old = linear_memory_block_num;

  // check if there are enough memory
  if (LINEAR_MEMORY_BLOCK_NUM_MAX < linear_memory_block_num + num) {
    printf("memory_grow: failed to grow memory\n");
    return -1;
  }

  linear_memory_block_num += num;
  return old;
}

int main() {
  // Entrypoint of ELF generated by Wasker
  wasker_main();
  return 0;
}